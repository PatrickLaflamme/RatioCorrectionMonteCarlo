{
    "collab_server" : "",
    "contents" : "MCfilled.contour <- function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, \n                                                                           length.out = ncol(z)), z, contourz=NULL, xlim = range(x, finite = TRUE), \n                              ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), \n                              levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, \n                              col = color.palette(length(levels) - 1), plot.title, plot.axes, \n                              key.title, key.axes, asp = NA, xaxs = \"i\", yaxs = \"i\", las = 1, \n                              axes = TRUE, frame.plot = axes, border=NA, ...) \n{\n  if (missing(z)) {\n    if (!missing(x)) {\n      if (is.list(x)) {\n        z <- x$z\n        y <- x$y\n        x <- x$x\n      }\n      else {\n        z <- x\n        x <- seq.int(0, 1, length.out = nrow(z))\n      }\n    }\n    else stop(\"no 'z' matrix specified\")\n  }\n  else if (is.list(x)) {\n    y <- x$y\n    x <- x$x\n  }\n  if (any(diff(x) <= 0) || any(diff(y) <= 0)) \n    stop(\"increasing 'x' and 'y' values expected\")\n  mar.orig <- (par.orig <- par(c(\"mar\", \"las\", \"mfrow\")))$mar\n  on.exit(par(par.orig))\n  w <- (3 + mar.orig[2L]) * par(\"csi\") * 2.54\n  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))\n  par(las = las)\n  mar <- mar.orig\n  mar[4L] <- mar[2L]\n  mar[2L] <- 1\n  par(mar = mar)\n  plot.new()\n  plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = \"i\", \n              yaxs = \"i\")\n  rect(0, levels[-length(levels)], 1, levels[-1L], col = col, border = border)\n  if (missing(key.axes)) {\n    if (axes) \n      axis(4)\n  }\n  else key.axes\n  box()\n  if (!missing(key.title)) \n    key.title\n  mar <- mar.orig\n  mar[4L] <- 1\n  par(mar = mar)\n  plot.new()\n  plot.window(xlim, ylim, \"\", xaxs = xaxs, yaxs = yaxs, asp = asp)\n  .filled.contour(x, y, z, levels, col)\n  if(!missing(contourz))\n    contour(x=x, y=y, z=contourz, add=T, levels=c(0.045,0.055), col = 'white', lwd=1.5)\n  if (missing(plot.axes)) {\n    if (axes) {\n      title(main = \"\", xlab = \"\", ylab = \"\")\n      Axis(x, side = 1)\n      Axis(y, side = 2)\n    }\n  }\n  else plot.axes\n  if (frame.plot) \n    box()\n  if (missing(plot.title)) \n    title(...)\n  else plot.title\n  invisible()\n}\n\nMCrainbow <-function (n, s = 1, v = 1, start = 0.36, end = 0.15, \n                      alpha = 1) \n{\n  if ((n <- as.integer(n[1L])) > 0) {\n    if (start == end || any(c(start, end) < 0) || any(c(start, \n                                                        end) > 1)) \n      stop(\"'start' and 'end' must be distinct and in [0, 1].\")\n    hsv(h = seq.int(start, ifelse(start > end, 1, 0) + end, \n                    length.out = n)%%1, s, v, alpha)\n  }\n  else character()\n}\n\nDatagen <- function(n_samples, sample_size, groups,mean,varcov, seed){\n  \n  library(mnormt)\n  #create a sample_size x n_samples array x groups\n  \n  if(!is.null(seed)){\n  set.seed(seed)\n  }\n  sample <- array(rmnorm(n = n_samples*sample_size,mean = mean, varcov = varcov), c(sample_size, n_samples, groups))\n  \n  #now change it to a more intelligible sample_size x groups x n_samples array\n  sample <- aperm(sample, c(1,3,2))\n  \n  return(sample)\n  \n}\n\ngenIndex <- function(data, condition){\n  ## Generates an index score for each data point. Generates it in one of 3 ways, as listed in the 'type' of condition.\n  ##\n  ## data      :: always has shape: sampleSize x 2 x n_samples\n  ##                                The 2 columns are: random sample dY and slope\n  ## condition :: type 1: participant-wise difference/slope\n  ##              type 2: participant-wise difference/overall slope\n  ##              type 3: taylor-corrected effect scores based on Feiller's theorem\n  \n  if(condition == 1){\n  indexData <- data[,1,]/data[,2,] #divide each individual effect by each individual slope\n  }\n  \n  else if(condition ==2){\n    indexData <- t(t(data[,1,])/apply(data[,2,], 2, mean)) #divide each individual effect by the sample mean slope\n  }\n  \n  else if (condition==3){\n    meanSlope <- apply(data[,2,], 2, mean) #calculate the sample mean slope\n    meanEffect <- apply(data[,1,], 2, mean) #calculate the sample mean effect\n    \n    indexData <- t(matrix(meanEffect/meanSlope, ncol=dim(data)[1], nrow=dim(data)[3])) * (1 + t(t(data[,1,])/meanEffect) - t(t(data[,2,])/meanSlope)) #perform the correction\n  }\n  else if(condition==4){\n    meanSlope <- apply(data[,2,], 2, mean) #calculate the sample mean slope\n    meanEffect <- apply(data[,1,], 2, mean) #calculate the sample mean effect\n    \n    indexData <- data[,1,] - t(matrix(meanEffect/meanSlope, ncol=dim(data)[1], nrow=dim(data)[3])) * data[,2,]\n  }\n  return(indexData)\n}\n\nrunTest <- function(effect, slopemean, slopevar, effectvar, r, seed = NULL,  sample_size=20, alpha=0.05, n_samples=100000, test=T){\n  ## n_samples    :: Number of times to simulate the experiment\n  ##\n  ## sample_size  :: Number of participants in each condition of the experiment\n  ##\n  ## varcov       :: Variance-covariance matrix of the bivariate normal data source\n  ##\n  ## mean         :: Population means of the two variables\n  ##\n  ## condition    :: list of conditions to generate\n  ##\n  ##                 type 1: participant-wise difference/slope\n  ##                 type 2: participant-wise difference/overall slope\n  ##                 type 3: taylor approximation of the fieler correction\n  ##\n  ## alpha        :: The nominal type 1 error rate.\n  ##\n  \n  covar <- r*sqrt(slopevar)*sqrt(effectvar)\n  \n  varcov <- array(c(effectvar, covar, covar, slopevar), dim=c(2,2))\n  \n  data <- Datagen(n_samples, sample_size, groups = 2, c(effect, slopemean), varcov, seed)\n  \n  popIndex <- 0\n  \n  indexed <- list()\n  \n  for(i in 1:3){\n    indexed <- c(indexed, list(genIndex(data, i) - popIndex))\n  }\n  \n  if(test){\n    type1ER <- c()\n    for(i in 1:3){\n      results <- apply(indexed[[i]], 2, t.test, conf.level = 1-alpha, mu=effect)\n      \n      pvalues <- unlist(sapply(results,'[',3))\n      \n      type1ER <- c(type1ER, sum(pvalues<=alpha)/n_samples)\n    }\n    \n    return(type1ER)\n  }\n  \n  return(indexed)\n  \n}\n\nrunSkew <- function(effect, slopemean, slopevar, effectvar, r, seed = NULL,  sample_size=20, alpha=0.05, n_samples=100000, test=T){\n  ## n_samples    :: Number of times to simulate the experiment\n  ##\n  ## sample_size  :: Number of participants in each condition of the experiment\n  ##\n  ## varcov       :: Variance-covariance matrix of the bivariate normal data source\n  ##\n  ## mean         :: Population means of the two variables\n  ##\n  ## condition    :: list of conditions to generate\n  ##\n  ##                 type 1: participant-wise difference/slope\n  ##                 type 2: participant-wise difference/overall slope\n  ##                 type 3: taylor approximation of the fieler correction\n  ##\n  ## alpha        :: The nominal type 1 error rate.\n  ##\n  \n  covar <- r*sqrt(slopevar)*sqrt(effectvar)\n  \n  varcov <- array(c(effectvar, covar, covar, slopevar), dim=c(2,2))\n  \n  data <- Datagen(n_samples, sample_size, groups = 2, c(effect, slopemean), varcov, seed)\n  \n  popIndex <- 0\n  \n  indexed <- list()\n  \n  for(i in 1:3){\n    indexed <- c(indexed, list(genIndex(data, i) - popIndex))\n  }\n  \n  if(test){\n    type1ER <- c()\n    for(i in 1:3){\n    results <- apply(indexed[[i]], 2, mean)\n    \n    type1ER <- c(type1ER, var(results))\n    }\n    \n    return(type1ER)\n  }\n  \n  return(indexed)\n  \n}",
    "created" : 1471906418592.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "7|1|71|0|\n75|1|84|0|\n86|70|101|0|\n184|131|229|0|\n",
    "hash" : "3654655503",
    "id" : "48E1073C",
    "lastKnownWriteTime" : 1480032375,
    "last_content_update" : 1480033602492,
    "path" : "~/Dropbox/MCratio/MCratioAnalysis/Monte Carlo Basic Functions.R",
    "project_path" : "Monte Carlo Basic Functions.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}