{
    "collab_server" : "",
    "contents" : "MCfilled.contour <- function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, \n                                                                           length.out = ncol(z)), z, contourz=NULL, xlim = range(x, finite = TRUE), \n                              ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), \n                              levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, \n                              col = color.palette(length(levels) - 1), plot.title, plot.axes, \n                              key.title, key.axes, asp = NA, xaxs = \"i\", yaxs = \"i\", las = 1, \n                              axes = TRUE, frame.plot = axes, border=NA, ...) \n{\n  if (missing(z)) {\n    if (!missing(x)) {\n      if (is.list(x)) {\n        z <- x$z\n        y <- x$y\n        x <- x$x\n      }\n      else {\n        z <- x\n        x <- seq.int(0, 1, length.out = nrow(z))\n      }\n    }\n    else stop(\"no 'z' matrix specified\")\n  }\n  else if (is.list(x)) {\n    y <- x$y\n    x <- x$x\n  }\n  if (any(diff(x) <= 0) || any(diff(y) <= 0)) \n    stop(\"increasing 'x' and 'y' values expected\")\n  mar.orig <- (par.orig <- par(c(\"mar\", \"las\", \"mfrow\")))$mar\n  on.exit(par(par.orig))\n  w <- (3 + mar.orig[2L]) * par(\"csi\") * 2.54\n  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))\n  par(las = las)\n  mar <- mar.orig\n  mar[4L] <- mar[2L]\n  mar[2L] <- 1\n  par(mar = mar)\n  plot.new()\n  plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = \"i\", \n              yaxs = \"i\")\n  rect(0, levels[-length(levels)], 1, levels[-1L], col = col, border = border)\n  if (missing(key.axes)) {\n    if (axes) \n      axis(4)\n  }\n  else key.axes\n  box()\n  if (!missing(key.title)) \n    key.title\n  mar <- mar.orig\n  mar[4L] <- 1\n  par(mar = mar)\n  plot.new()\n  plot.window(xlim, ylim, \"\", xaxs = xaxs, yaxs = yaxs, asp = asp)\n  .filled.contour(x, y, z, levels, col)\n  if(!missing(contourz))\n    contour(x=x, y=y, z=contourz, add=T, levels=c(0.04,0.06), col = 'white', lwd=1.5)\n  if (missing(plot.axes)) {\n    if (axes) {\n      title(main = \"\", xlab = \"\", ylab = \"\")\n      Axis(x, side = 1)\n      Axis(y, side = 2)\n    }\n  }\n  else plot.axes\n  if (frame.plot) \n    box()\n  if (missing(plot.title)) \n    title(...)\n  else plot.title\n  invisible()\n}\n\nMCrainbow <-function (n, s = 1, v = 1, start = 0.36, end = 0.15, \n                      alpha = 1) \n{\n  if ((n <- as.integer(n[1L])) > 0) {\n    if (start == end || any(c(start, end) < 0) || any(c(start, \n                                                        end) > 1)) \n      stop(\"'start' and 'end' must be distinct and in [0, 1].\")\n    hsv(h = seq.int(start, ifelse(start > end, 1, 0) + end, \n                    length.out = n)%%1, s, v, alpha)\n  }\n  else character()\n}\n\nDatagen <- function(n_samples, sample_size, groups,mean,varcov){\n  \n  library(mnormt)\n  #create a sample_size x n_samples array x groups\n  sample <- array(rmnorm(n = n_samples*sample_size,mean = mean, varcov = varcov), c(sample_size, n_samples, groups))\n  \n  #now change it to a more intelligible sample_size x groups x n_samples array\n  sample <- aperm(sample, c(1,3,2))\n  \n  return(sample)\n  \n}\n\ngenIndex <- function(data, condition){\n  ## Generates an index score for each data point. Generates it in one of 3 ways, as listed in the 'type' of condition.\n  ##\n  ## data      :: always has shape: sampleSize x 2 x n_samples\n  ##                                The 2 columns are: random sample dY and slope\n  ## condition :: type 1: participant-wise difference/slope\n  ##              type 2: participant-wise difference/overall slope\n  ##              type 3: taylor-corrected effect scores based on Feiller's theorem\n  \n  assertthat::are_equal(dim(data)[2], 2)\n  \n  if(condition == 1){\n  indexData <- data[,1,]/data[,2,] #divide each individual effect by each individual slope\n  }\n  \n  else if(condition ==2){\n    indexData <- t(t(data[,1,])/apply(data[,2,], 2, mean)) #divide each individual effect by the sample mean slope\n  }\n  \n  else if (condition==3){\n    meanSlope <- apply(data[,2,], 2, mean) #calculate the sample mean slope\n    meanEffect <- apply(data[,1,], 2, mean) #calculate the sample mean effect\n    \n    indexData <- meanEffect/meanSlope * (1 + t(t(data[,1,])/meanEffect) - t(t(data[,2,])/meanSlope)) #perform the correction\n  }\n  return(indexData)\n}\n\nrunTest <- function(n_samples, sample_size, varcov, mean, condition, alpha, plot=F){\n  ## n_samples    :: Number of times to simulate the experiment\n  ##\n  ## sample_size  :: Number of participants in each condition of the experiment\n  ##\n  ## varcov       :: Variance-covariance matrix of the bivariate normal data source\n  ##\n  ## mean         :: Population means of the two variables\n  ##\n  ## condition    :: type 1: participant-wise difference/slope\n  ##                 type 2: participant-wise difference/overall slope\n  ##\n  ## alpha        :: The nominal type 1 error rate.\n  ##\n  \n  data <- Datagen(n_samples, sample_size, groups = 2, mean, varcov)\n  \n  popIndex <- mean[1]/mean[2]\n  \n  indexed <- genIndex(data, condition) - popIndex\n  \n  if(plot){hist(indexed, density = T)}\n  \n  results <- apply(indexed, 2, t.test, conf.level = 1 - alpha)\n  \n  pvalues <- unlist(sapply(results,'[',3))\n  \n  type1ER <- sum(pvalues<=alpha)/n_samples\n  \n  return(type1ER)\n  \n}\n\n\n\n# ER1 <- array(data = NA, dim = c(20,20))\n# ER2 <- array(data = NA, dim = c(20,20))\n# ER3 <- array(data = NA, dim = c(20,20))\n# \n# \n# for(i in seq(0.2,4, by = 0.2)){\n# \n#   for(j in seq(0.2,4, by = 0.2)){\n# \n#     ER1[i*5,j*5] <- runTest(100000, 20, array(c(1,0,0,1), dim=c(2,2)), mean = c(i,j), condition = 1, 0.05)\n#     ER2[i*5,j*5] <- runTest(100000, 20, array(c(1,0,0,1), dim=c(2,2)), mean = c(i,j), condition = 2, 0.05)\n#     ER3[i*5,j*5] <- runTest(100000, 20, array(c(1,0,0,1), dim=c(2,2)), mean = c(i,j), condition = 3, 0.05)\n#     \n#     print(c(i*5,j*5))\n#   }\n# \n# }\n# remove(i,j)\n# \n# logER1 <- log(ER1)\n# logER2 <- log(ER2)\n# logER3 <- log(ER3)\n# ERtick <- c(0.005, 0.01,0.025,0.05,0.1,0.2,0.4,0.8)\n# \n# \n# MCfilled.contour(x = seq(0,3.8,length.out = 20),\n#                  y = seq(0.2,4,length.out = 20),\n#                  z = logERvar1,\n#                  contourz = ERvar1,\n#                  zlim = c(-5,0),\n#                  nlevels = 100,\n#                  color.palette = MCrainbow,\n#                  xlab = 'slope variance',\n#                  ylab = 'difference variance',\n#                  main = expression(paste(\"Actual \", alpha,\" for Index method: nominal \",alpha,\" = 0.05\")),\n#                  key.axes = axis(4, at = log(ERtick), label = ERtick))\n# dev.copy(pdf, '~/Dropbox/MCratio/Index-var.pdf')\n# dev.off()\n# \n# \n# MCfilled.contour(x = seq(0,3.8,length.out = 20),\n#                  y = seq(0.2,4,length.out = 20),\n#                  z = logER1,\n#                  contourz = ER1,\n#                  zlim = c(-5,0),\n#                  nlevels = 100,\n#                  color.palette = MCrainbow,\n#                  xlab = 'slope mean',\n#                  ylab = 'effect mean',\n#                  main = expression(paste(\"Actual \", alpha,\" for Index method: nominal \",alpha,\" = 0.05\")),\n#                  key.axes = axis(4, at = log(ERtick), label = ERtick))\n# dev.copy(pdf, '~/Dropbox/MCratio/Index-slope-diff.pdf')\n# dev.off()\n# \n# MCfilled.contour(x = seq(0,3.8,length.out = 20),\n#                  y = seq(0.2,4,length.out = 20),\n#                  z = logERvar2,\n#                  contourz = ERvar2,\n#                  zlim = c(-5,0),\n#                  nlevels = 100,\n#                  color.palette = MCrainbow,\n#                  xlab = 'slop variance',\n#                  ylab = 'difference variance',\n#                  main = expression(paste(\"Actual \", alpha,\" for zero-variance method: nominal \",alpha,\" = 0.05\")),\n#                  key.axes = axis(4, at = log(ERtick), label = ERtick))\n# \n# dev.copy(pdf, '~/Dropbox/MCratio/zeroVariance-var.pdf')\n# dev.off()\n# \nMCfilled.contour(x = seq(0,3.8,length.out = 20),\n                 y = seq(0.2,4,length.out = 20),\n                 z = logER3,\n                 contourz = ER3,\n                 zlim = c(-5.3,0),\n                 nlevels = 100,\n                 color.palette = MCrainbow,\n                 xlab = 'effect mean',\n                 ylab = 'slope mean',\n                 main = expression(paste(\"Actual \", alpha,\" for taylor method: nominal \",alpha,\" = 0.05\")),\n                 key.axes = axis(4, at = log(ERtick), label = ERtick))\n\ndev.copy(pdf, '~/Dropbox/MCratio/Taylor-slope-diff.pdf')\ndev.off()\n\n\n",
    "created" : 1472232516909.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "672561104",
    "id" : "1FB7E5D5",
    "lastKnownWriteTime" : 1471907514,
    "last_content_update" : 1471907514,
    "path" : "~/Dropbox/MCratio/Monte Carlo Basic Functions-DEP.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}